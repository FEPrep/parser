{
    "Basic Data Structures": {
        "1": {
            "rects": {
                "1": {
                    "x0": 54.02399826049805,
                    "y0": 147.01402282714844,
                    "x1": 561.0499877929688,
                    "y1": 707.9555053710938
                }
            },
            "raw": "Suppose we have a stack implemented with an array as shown in the structure below.  Write a function \ncalled grow_stack that will increase the stack\u2019s capacity while preserving the exact values currently in the \nstack and their current locations. Your function should take 2 parameters: a pointer to the current stack \nand an integer representing the amount to increase the stack\u2019s capacity by.  You may not use the realloc \nfunction. You may assume s isn't NULL and pts to a valid struct stack. You may assume that capacity \nstores the current size of the array that the pointer array is pointing to and that top represents the number \nof items currently in the stack (items are stored in indexes 0 through top-1). \nstruct Stack { \n    int *array; \n    int top; \n    int capacity; \n}; \nvoid grow_stack(struct Stack *s, int increase) { \n}",
            "sub_questions": [],
            "question_number": 1,
            "max_points": 10,
            "category": "DSN ",
            "sub_category": "Dynamic Memory Management in C"
        },
        "2": {
            "rects": {
                "2": {
                    "x0": 54.02399826049805,
                    "y0": 89.14402770996094,
                    "x1": 546.5800170898438,
                    "y1": 690.1934814453125
                }
            },
            "raw": "Suppose we have a singly linked list implemented with the structure below.  Write a function that will \nconvert it into a circular linked list and return the pointer to the beginning of the circle.  \nstruct node { \n   int num; \n   struct node* next; \n}; \nstruct node* make_circle(struct node* head) {       \n}",
            "sub_questions": [],
            "question_number": 2,
            "max_points": 10,
            "category": "DSN ",
            "sub_category": "Linked Lists"
        }
    },
    "Advanced Data Structures": {
        "1": {
            "rects": {
                "5": {
                    "x0": 54.02399826049805,
                    "y0": 147.01402282714844,
                    "x1": 410.69000244140625,
                    "y1": 248.2419891357422
                }
            },
            "raw": "Draw a single binary search tree that meets all the following conditions:\n\uf0b7 The tree contains 7 nodes. \n\uf0b7 The tree\u2019s pre-order traversal is the same as its in-order traversal. \n\uf0b7 The tree does not contain any duplicate values. \nIf it is not possible to draw such a tree, say so and explain why not.",
            "sub_questions": [],
            "question_number": 1,
            "max_points": 5,
            "category": "ALG ",
            "sub_category": "Binary Trees"
        },
        "2": {
            "rects": {
                "6": {
                    "x0": 54.02399826049805,
                    "y0": 89.14402770996094,
                    "x1": 556.9200439453125,
                    "y1": 574.0220336914062
                }
            },
            "raw": "Consider the following strings and their corresponding hash values, which have been generated by some \nhash function: \nhash(\u201csquiggle\u201d) = 301 \nhash(\u201cgiggle\u201d) = 174 \nhash(\u201chaggle\u201d) = 431 \nhash(\u201cgaggle\u201d) = 263 \nhash(\u201cstraggle\u201d) = 361 \na) (7 pts) Insert the strings above into the following hash table using quadratic probing. In doing so, \ninsert them in the order given above (i.e., starting with \u201csquiggle\u201d, then \u201cgiggle\u201d, and so on). Note that \nthe hash table\u2019s length is 11 (not 10). \n \n \n \n \n \n \n \n \n \n \n \n0 \n1 \n2 \n3 \n4 \n5 \n6 \n7 \n8 \n9 \n10 \nb) (3 pts) What is one hash value, h, between 100 and 500 (inclusively) that would cause a collision to \noccur in your final table from part (a) of this problem, but which also satisfies all of the following \nadditional restrictions: \nh % table_length != hash(\u201csquiggle\u201d) % table_length \nh % table_length != hash(\u201cgiggle\u201d) % table_length \nh % table_length != hash(\u201chaggle\u201d) % table_length \nh % table_length != hash(\u201cgaggle\u201d) % table_length \nh % table_length != hash(\u201cstraggle\u201d) % table_length",
            "sub_questions": [],
            "question_number": 2,
            "max_points": 10,
            "category": "ALG ",
            "sub_category": "Hash Tables"
        }
    },
    "Algorithm Analysis": {
        "1": {
            "rects": {
                "9": {
                    "x0": 54.02399826049805,
                    "y0": 147.49400329589844,
                    "x1": 558.0922241210938,
                    "y1": 495.2720031738281
                }
            },
            "raw": "Given an array, vals, of size n, one can determine the sum of the elements in the array from index i \nthrough index j  (i \u2264 j), inclusive, simply by running a for loop through the elements: \nint sum = 0; \nfor (int z=i; z<=j; z++) \n   sum += vals[z]; \nThis type of sum is known as a contiguous subsequence sum. \nNote: There are more efficient ways to do this if many sums of this format need to be determined, but \nfor the purposes of this problem, assume that this is how such a sum is determined. \n(a) (3 pts) What is the worst case run time of answering q questions about contiguous subsequence sums \non an array of size n? Express your answer in Big-Oh notation, in terms of both n and q. Give a brief \njustification for your answer. \n(b) (2 pts) What is the best case run time of answering q questions about contiguous subsequence sums \non an array of size n? Express your answer in Big-Oh notation, in terms of both n and q. Give a brief \njustification for your answer.",
            "sub_questions": [],
            "question_number": 1,
            "max_points": 5,
            "category": "ANL ",
            "sub_category": "Algorithm Analysis"
        },
        "2": {
            "rects": {
                "10": {
                    "x0": 54.02399826049805,
                    "y0": 88.88021087646484,
                    "x1": 561.0501098632812,
                    "y1": 712.5239868164062
                }
            },
            "raw": "Querying a user in our data base of 104 users take 10 milliseconds. The runtime of the query is\nlogarithmic with respect to the number of users. Namely, if there are n users, a query takes O(lg n) time.\nHow many users can we support while taking no more than 20 milliseconds per query? \n________________",
            "sub_questions": [],
            "question_number": 2,
            "max_points": 10,
            "category": "ANL ",
            "sub_category": "Algorithm Analysis"
        }
    },
    "Algorithms": {
        "1": {
            "rects": {
                "13": {
                    "x0": 54.02399826049805,
                    "y0": 119.41398620605469,
                    "x1": 561.196044921875,
                    "y1": 722.52294921875
                }
            },
            "raw": "We call a list of positive integers nice if each pair of consecutive elements shares a common divisor \ngreater than 1. For example, the list 18, 15, 35, 40 is nice because 18 and 15 are both divisible by 3, 15 \nand 35 are both divisible by 5, and 35 and 40 are both divisible by 5 as well. Given a list of unique\npositive integers, complete the recursive code below so that it counts the number of permutations of an \noriginal list that are nice lists. (For example, for the 4 numbers above, there are 12 nice arrangements: \n[18,15,35,40], [18,15,40,35], [18,40,15,35], [18,40,35,15], [15,18,40,35], [15,35,40,18], [35,15,18,40], \n[35,15,40,18], [35,40,18,15], [35,40,15,18], [40,18,15,35], and [40,35,15,18].)  \nThe strategy the code below uses is to go through each permutation of the integers 0, 1, 2, \u2026, n-1, where\nn is the number of values being considered. For each permutation, the evaluation function returns 1 if \nthe order of the values creates a nice list, and 0 otherwise. Over all permutations, these values are added. \nNote: the gcd function provided returns the greatest common divisor shared by the 2 positive integer \nparameters. \nint numArr(int values[], int perm[], int used[], int k, int n) { \n   if (k == n) \n       _______________________________________________________ ; \n   int res = 0; \n   for (int i=0; i<n; i++) { \n       if (______________) { \n           used[i] = ____; \n           perm[k] = i; \n           res += numArr(values, perm, used, ________ , ______ ); \n           used[i] = ____; \n       } \n   } \n   return res; \n} \n// Returns 1 if and only if values[perm[0]], values[perm[1]], \u2026, values[perm[n-1]] \n// is a nice list. Returns 0 otherwise. \nint eval(int values[], int perm[], int n) { \n   for (int i=0; i< ______ ; i++) \n       if ( gcd( ______________________ , _______________________ ) == ____ ) \n           return 0; \n   return 1; \n} \nint gcd(int a, int b) { \n   return b == 0 ? a : gcd(b, a%b); \n}",
            "sub_questions": [],
            "question_number": 1,
            "max_points": 10,
            "category": "DSN ",
            "sub_category": "Recursive Coding"
        },
        "2": {
            "rects": {
                "14": {
                    "x0": 54.02399826049805,
                    "y0": 89.14402770996094,
                    "x1": 560.31591796875,
                    "y1": 454.6920166015625
                }
            },
            "raw": "(a) (5 pts) Show the state of the following array below after each iteration of an Insertion Sort. The\nresults after the first iteration and last iteration are included for clarity. \nOriginal \n13 \n6 \n9 \n44 \n18 \n22 \n3 \n11 \n1st iteration \n6 \n13 \n9 \n44 \n18 \n22 \n3 \n11 \n2nd iteration \n \n \n \n \n \n \n \n \n3rd iteration \n \n \n \n \n \n \n \n \n4th iteration \n \n \n \n \n \n \n \n \n5th iteration \n \n \n \n \n \n \n \n \n6th iteration \n \n \n \n \n \n \n \n \n7th iteration \n3 \n6 \n9 \n11 \n13 \n18 \n22 \n44 \n(b) (5 pts) List the worst case run time of each of the following sorting algorithms, in terms of n, the \nnumber of items being sorted. \n(i) Insertion Sort \n \n \n \n____________ \n(ii) Selection Sort \n \n \n \n____________ \n(iii) Heap Sort  \n \n \n \n____________ \n(iv) Merge Sort \n \n \n \n____________ \n(v) Quick Sort  \n \n \n \n____________",
            "sub_questions": [],
            "question_number": 2,
            "max_points": 10,
            "category": "ALG ",
            "sub_category": "Sorting"
        },
        "3": {
            "rects": {
                "15": {
                    "x0": 54.02399826049805,
                    "y0": 89.14402770996094,
                    "x1": 561.219970703125,
                    "y1": 473.66351318359375
                }
            },
            "raw": "There are a total of 25 cards, numbered 0 through 24. We can represent a set of cards with a single \ninteger by setting the ith bit to 1 if the set contains card i, and setting the bit to 0 otherwise. For example, \nthe set of cards {2, 6, 7} would be stored as the integer 196, since 196 = 27 + 26 + 22. Two sets of cards\nare disjoint, if and only if no card appears in both sets. Complete the function below so that it returns 1 if \nthe sets of cards represented by the integers set1 and set2 are disjoint, and returns 0 if they are not \ndisjoint. (For example, disjoint(196, 49) should return 1 because 49 = 25 + 24 + 20, and there is no\ncommon value in the two sets {2, 6, 7} and {0, 4, 5}. On the other hand, disjoint(196, 30) should return \n0 because 30 = 24 + 23 + 22 + 21, so that card number 2 is included in both sets 196 and set 30.) \n// Pre-condition: set1 and set2 are bitmasks in between 0 and \n//                (1<<25)-1. \n// Post-condition: Returns 1 if the two bitmasks are disjoint,  \n//                 meaning that the sets they represent don't have \n//                 any items in common, and returns 0 otherwise, if \n//                 the two represented sets do have common items. \nint disjoint(int set1, int set2) { \n}",
            "sub_questions": [],
            "question_number": 3,
            "max_points": 5,
            "category": "ALG ",
            "sub_category": "Bitwise Operators"
        }
    }
}